INTEGRATED IV- Group 2: Cell Growth and Differentiaton
Ostolaza M., Gómez O., Marcos M. & Montalbán SM. UVic-UCC
---
title: "B2 Cell Growth & differentiation"
author: "Sanu Maya Montalbán Ferrer"
date: "2025-06-03"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    number_sections: false
    toc_collapsed: false
theme: lumen
editor_options:
  markdown:
---

# 1.PRE DATA TREATMENT

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r echo=FALSE, results='hide',message=FALSE}
#Load packages:
library(ggplot2)
library(DESeq2)
library(edgeR)
library(ggplot2)
library(knitr)

library(EnhancedVolcano)
library(pheatmap)
library(topGO)
library(org.Hs.eg.db)

#in case you need to dowload the librarires some of them aren't in CRAA repository copy the following code(Run only once!):
##################From bioconductor:
##Deseq2
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("DESeq2")
#EnhancedVolcano
BiocManager::install('EnhancedVolcano')
#or 
devtools::install_github('kevinblighe/EnhancedVolcano')
##edgeR
BiocManager::install("edgeR")
#topGO
BiocManager::install("topGO")
#clusterProfiler
BiocManager::install("clusterProfiler")
#org.Hs.eg.db
BiocManager::install("org.Hs.eg.db")
##############From CRAN:
##ggplot2
install.packages("ggplot2")
##pheatmap
install.packages("pheatmap")
#knitr
install.packages("knitr")


# to let people know what version is being used
sessionInfo()
```

### 1.1 DATA LOADING
Analysis of data from: https://pmc.ncbi.nlm.nih.gov/articles/PMC9687758/#biomolecules-12-01693-f005. After preprocessing the data a gene expression matrix has been obtained. Combining this information with the corresponding metadata (clinical information) we can proceed with further analysis:

```{r}
setwd("/Users/sanumaya/Downloads/galaxyB2 group")
```

Loading the data obtained by galaxy (Feature counts annotated)
```{r}

SRR21709659 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709659.tabular", row.names=1)
SRR21709660 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709660.tabular", row.names=1)
SRR21709661 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709661.tabular", row.names=1)
SRR21709662 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709662.tabular", row.names=1)

SRR21709663 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709663.tabular", row.names=1)
SRR21709664 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709664.tabular", row.names=1)
SRR21709665 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709665.tabular", row.names=1)
SRR21709666 <- read.delim("/Users/sanumaya/Downloads/galaxyB2 group/SRR21709666.tabular", row.names=1)


```

Joining the different table of counts:
    * C bind function can only be used when rows number are the same
    
```{r}
counts_all <- cbind(SRR21709659, SRR21709660)
counts_all <- cbind(counts_all, SRR21709661)
counts_all <- cbind(counts_all, SRR21709662)
counts_all <- cbind(counts_all, SRR21709663)
counts_all <- cbind(counts_all, SRR21709664)
counts_all <- cbind(counts_all, SRR21709665)
counts_all <- cbind(counts_all, SRR21709666)

```

* Loading metadata
```{r}
metadata <- read.csv2("Metadata.csv", dec = ",", row.names = 1)
```

In order to perform deseq2 metadata rows and column names need to be the same:
```{r}
rownames(metadata) %in% colnames (counts_all) 

#exploration of the matryx
counts_all[1:25, ]
dim(counts_all)

head(metadata)
table(metadata$Condition)
```


### 1.2 GENERAL EXPLORATION, NORMALISATION OF THE DATA

#### Observation of library size
  *  Size is similiar, which is positive meaning that the variation is minimal and probably due to inevitable experimental human mistakes
```{r}
barplot(colSums(counts_all),las=2, cex.names = 0.6,
        main ="Barplot of library sizes")
```
#### Normalisation
RNAseq data is not normally distributed. Prior to differential gene expression analysis, the count matrix should be normalized.
```{r}
CPM <- cpm(counts_all) 
CPM[1:5, 1:5]

drop <- which(apply(CPM, 1, median) < 0.3)
#Which is the number of droped genes? 
length (drop)
##Write a command here
#REMEMBER: lenght(vector) i dim(Dataframe)

counts <- counts_all[-drop, ]  
CPM <- CPM[-drop, ]
nrow(CPM) 
```

 
### 1.3 DESE2 OBJECT CREATION AND EXPLORATORY DATA ANALYSIS:

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts_all,
                              colData = metadata,
                              design = ~ Condition)

dds$condition <- relevel(dds$Condition, ref = "Control")
```

#### 1.3.1 Principal Component Analysis PCA EXPLORATION:

Principal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction).
Before plotting in a PCA it is necessary to normalize first. In this case we will use rlog normalization.

rlog normalization. This function transforms the count data to the log2 scale in a way which minimizes differences between samples for rows with small counts, and which normalizes with respect to library size (number of sequences obtained after sequencing).

```{r}
rsel <- rlog(dds, blind=TRUE)
```


```{r pca, echo=FALSE, out.width="2000px" }


PCA <- ggplot(pca, aes(PC1, PC2)) +
  geom_point(aes(colour = factor(Condition), shape = factor(Sex)), size = 4) +
  scale_color_manual(values=c("#bab","blue")) + # Colors for Condition
  scale_shape_manual(values=c(16, 17)) + # Shapes for Sex (can be adjusted)
  theme_bw() + 
  labs(title = "PCA - Principal Components Analysis", 
       y = paste0("PC2: ", vars[2]), 
       x = paste0("PC1: ", vars[1]))

PCA
```


#### 1.3.2 HEATMAP EXPLORATION:
 
```{r}
pheatmap(log2(CPM + 1), # 0.3 drop  
         show_rownames = F, 
         annotation_col = metadata)
```
 

## 2. DIFFERENTIAL EXPRESSION ANALYSIS WITH DESEQ2:
```{r}
# the algorithm normalizese the data amb built an statistical  models to make the differential expression tests.
dds <- DESeq(dds)
res <- results(dds) #saving results as a variable
# in order to obsesrve the results a dataframe is created
df <- data.frame(results(dds))

res01 <- results(dds, alpha=0.05) # every pvalue inferior to 0.05 is considered significant
summary(res01)
#convert it as a dataframe:

res_sig <- as.data.frame(res01)
#NA values correspond to filtered genes. Lowly expressed, in few samples.
```
##### Note: logfold
  * negatve doown regulated
  * positive ones up regulated - more expressed 
  * log2((Expr * grp1)/(exore grp2))
      --> grp2--> ref control
     --->grp1--> casa
if the ratio is hgiheer than 0 the loog will be postive if the ratio is lower than 0 the log will be negative

  * as.data.frame vs data.frame --> f(x) igual, a vegades depenet de l¡objecte que vols formar 


### 2.1 Volcano plot
How many genes are upregulated? And downregulated? -->
```{r}
EnhancedVolcano <- EnhancedVolcano(res, lab = rownames(res), x = 'log2FoldChange', y = 'padj',
                                            labSize = 2,  pointSize = 1.5, xlim = c(-7,7),ylim = c(0,30),FCcutoff = 0.58, pCutoff = 0.05, title = "Volcano Plot Control vs Treatment")

EnhancedVolcano
```
 
Saving the top 30 genes that are more significant ( adj p-val < 0.05) and that are up-regulated.

```{r}
res_df <- as.data.frame(res)

# Filter by padj < 0.05
res_filtered <- res_df[which(res_df$padj < 0.05),]

# Sort by log2FoldChange in descending order
res_sorted <- res_filtered[order(res_filtered$log2FoldChange, decreasing = TRUE),]

# Select the first 30 rows
top_30 <- head(res_sorted, 30)
indices <- rownames(top_30)
indices
```



Repeating the heatmap considering only differential expressed genes:

```{r}
data_counts <- log2(CPM + 1)
data_counts <- subset(data_counts, rownames(data_counts) %in% rownames(res_filtered))
pheatmap(data_counts, 
         show_rownames = F, 
         annotation_col = metadata)
```

## 3. GO ENRICHMENT


```{r}
# topGO requires all genes as a named list of P-values, plus a function to select significant genes (see below)
# in this case 'allGenes' or the 'universe' of genes are all the genes that have been tested in the DGE analysis 

#Create a res table without the NAs:
res_ok <- na.omit(res)
allGenes <- res_ok$padj
names(allGenes) <- rownames(res_ok)

# Create topGO object
GOdata <- new("topGOdata",
              ontology = "BP",                 # We are interested in the 'Biological Process' domain of GO 
              allGenes = allGenes,             # The 'universe' of genes
              geneSel = function(p){p < 0.05}, # Define function (selects genes with adjusted P-values below 0.05)
              annotationFun = annFUN.org,      # Function to map gene IDs to GO terms
              mapping = "org.Hs.eg.db",        # H. sapiens annotation
              ID = "entrez")                  # We are working with entrez gene IDs

# Run Fisher test  
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")

# Results (top 100)
GOres <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 100) 

head(GOres)
```


# Autonomous Work day 8
"152816"    "57611"     "3694"      "1746"      "753"   
```{r}
indices[1:2]

data_counts_subB2 <- t(counts_all)
data_counts_subB2 <- data_counts_subB2[, c("152816", "57611")]
colnames(data_counts_subB2) <- c("gene1_B2", "gene2_B2")
ggplot(as.data.frame(data_counts_subB2), aes(x = gene1_B2, y= gene2_B2)) +
geom_point() +
labs(tittle = "Scatter Plot", x = "X axis", y = "Y axis")


cor.test(data_counts_subB2[, 1], data_counts_subB2[, 2], method = "spearman")
tail_30 <- tail(res_sorted, 30)

data_counts_sub_underrepB2 <- t(counts_all)
data_counts_sub_underrepB2 <- as.data.frame(data_counts_sub_underrepB2[, c("11170")])
# Add the variable in the latest (condition)
data_counts_sub_underrepB2$Condition <- metadata$Condition
colnames(data_counts_sub_underrepB2)[1] <- "geneB2"
ggplot(data_counts_sub_underrepB2, aes(x = Condition, y= geneB2)) +
geom_boxplot()+
labs(tittle = "Distribution of the most underrepresented gene across conditions", x ="Group", y = "Raw counts")
```



# 4. Development of predictive models using different genes

```{r}
# escollim els 5 gens més expressats 

# Sort by log2FoldChange in descending order
res_sorted5 <- res_filtered[order(res_filtered$log2FoldChange, decreasing = TRUE),]

# Select the first 30 rows
top_5 <- head(res_sorted, 5)
indices5 <- rownames(top_5)
indices5

# gene 152816, 57611, 3694, 1746 & 753
```

NOTA: relaemnt podem agafar els 3 gens pq 5 són masses models més de 20....

## 4.1 Creation of dataframe with all the data needed
